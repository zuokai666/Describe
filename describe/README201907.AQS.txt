AQS，抽象队列同步器，是jdk中一个抽象类，主要定义了节点类，队列的head与tail，state（同步状态）
其中的CAS操作都是调用的Unsafe类的方法
acquire(int arg):将会把int值传给state，可重入性，state++
实现子类Sync
存在于各个场景中：
1.CountDownLatch
2.ReentrantLock
3.ReentrantReadWriteLock：读写分离，共享锁与独占锁
4.Semaphore
5.LimitLatch
6.ThreadPoolExecutor中的Worker任务继承自AQS


CAP定理：一致性，可用性，分区容错性（区间通信可能失败），3个特性不可能同时做到
P一定存在，要么满足C，要么满足A。

一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。

Two-phase Commit：二阶段提交，为了保持分布式系统下所有节点保持事务一致性而设计的一种算法。
协调者：参与者 = 1：n
将之前的一次提交请求分为2个阶段，第一个投票阶段，第二实际提交阶段


CountDownLatch：例子
对于倒计数器，一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检测。
只有等到所有的检查完毕后，引擎才能点火。那么在检测环节当然是多个检测项可以同时进行的。

我司API接口要求响应时间在200ms以内，但是如果一个接口内部依赖多个三方/外部服务，那串行调用接口的RT必然很久，
所以个人用的最多的是接口RT优化场景，内部服务并行调用。

结果：可以提高效率，提高响应速度，但是如果有结果依赖关系就不适用了

适用场景：1.相互无依赖；2.时间限制严格




Semaphore：信号量
在JDK1.5被引入，用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界

例子：
以一个停车场是运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，
然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，
如果又离开两辆，则又可以放入两辆，如此往复。这个停车系统中，每辆车就好比一个线程，看门人就好比一个信号量，看门人限制了可以活动的线程。
假如里面依然是三个车位，但是看门人改变了规则，要求每次只能停两辆车，那么一开始进入两辆车，后面得等到有车离开才能有车进入，
但是得保证最多停两辆车。对于Semaphore类而言，就如同一个看门人，限制了可活动的线程数。


独占锁：state=1
信号量：state=n
共享锁：state='+oo'

这个都是AQS抽象的功劳


Tomcat使用LimitLatch类实现了对请求连接数的控制








