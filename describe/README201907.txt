当偿还借据时，保证线程安全，同步
acct_loan 表：
id:1
name:左凯
money:100
lockFlag:0

当偿还借据时，使用独占锁
{
	begin:
	select lockFlag from acct_loan where id = '1' for update;设置锁等待超时时间
	if(lockFlag == 0){
		sys:开始偿还
		...
	}else{
		sys:有操作在应用该借据，稍等
	}
	commit;
}








某些环节快速失败“fail fast原则”
Fail fast原则是当主流程的任何一步出现问题的时候，应该快速合理地结束整个流程，而不是等到出现负面影响才处理
ConfigurablePropertyResolver.validateRequiredProperties验证必输属性，就可以做到fail fast

系统一般都有第三方依赖，比如数据库，三方接口等。系统开发的时候，需要对第三方保持怀疑，避免第三方出现问题时候的连锁反应，导致宕机。

首先针对超时不可以做重路由，因为socket timeout是不能确定这笔交易是否发送到了三方，是否已经成功或者失败
幂等性






转化系统的设计：
首先设计一个ConversionService顶级接口，用于客户的使用

然后设计转换器，具体到一个类型到一个类型，例如StringToBooleanConverter，然后这就会产生一个关于Converter转换器的类继承体系
因为String is final和Boolean is final，所以这个是1:1

有人需要从String->Byte/Integer/Long等等，难道我们也需要写这么多类吗，然后出现了ConverterFactory，转化工厂，1:N，有效的减少了类的数量
还需要注意类是否可以继承
尤其是在最底层实现，Spring经常喜欢写出一个Util类，来做到通用

GenericConverter N:N是转化服务中最复杂的转化器

现在的问题是3种类型的转换器，如何保存呢？这里使用GenericConverter为元素的ConverterRegistry
其它的2个元素使用适配器模式，来加入到转换器注册中心，实现方式，继承GenericConverter，构造方法传入，然后实现方法


ConverterRegistry是转换器的注册中心，提供了对转换器的增删改查管理方法

然后到了具体实现GenericConversionService中，提供了转化器缓存，设计到缓存就要考虑线程安全问题
使用ConcurrentReferenceHashMap来保证，键值对使用软引用，弱引用，所以是线程安全的。


private final Map<ConverterCacheKey, GenericConverter> converterCache = new ConcurrentReferenceHashMap<>(64);
ConverterCacheKey需要重写equals()和hashCode()
equals:先判断地址，在使用instanceof判断类型，在判断里面每一个属性


DefaultConversionService的功能是注册系统提供了一些默认的转化器，并且里面设计了基于volatile关键字的双重检查锁的单例模式
public static void addDefaultConverters(ConverterRegistry converterRegistry) {}
这里触动很大，考虑到了通用性，和最小依赖，注册转化器就应该只是依赖ConverterRegistry，很厉害




http://os.51cto.com/art/201108/285359.htm
https://blog.csdn.net/yangbodong22011/article/details/73369426
负载均衡：2种方式，硬件方式，软件方式
weighted round-robin：加权轮询调度
Nginx Smooth weighted round-robin SWRR负载均衡算法

Tomcat Acceptor线程转发消息到Poller线程使用轮询算法：哈希，取余法，O(1)
	
	public Poller getPoller0() {
        int idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;
        return pollers[idx];
    }

Ribbon的负载均衡策略及原理
https://blog.csdn.net/wudiyong22/article/details/80829808

负载均衡有好几种实现策略，常见的有：
	随机 (Random)
	轮询 (RoundRobin)
	一致性哈希 (ConsistentHash)
	哈希 (Hash)
	加权（Weighted）

	
	
	
	
	
	
在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。
当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。
而用来选择淘汰哪一页的规则叫做页面置换算法。

LRU:Least recent used最近最少使用




2019年7月31日16:52:10

BigDecimal
不建议采用传入double构造，会有精度问题，带来不可预知性，通常建议优先使用String构造方法 
new BigDecimal(Double.toString(val));

   public BigDecimal add(BigDecimal value); //加法
　　public BigDecimal subtract(BigDecimal value); //减法 
　　public BigDecimal multiply(BigDecimal value); //乘法
　　public BigDecimal divide(BigDecimal value); //除法




