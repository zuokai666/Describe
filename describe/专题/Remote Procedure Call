RPC：远程过程调用，相对于单体应用中的本地方法调用，其中涉及到两块内容，代理模式与TCP/IP协议簇与序列化反序列化，调用者无感知
在现在通用的面向接口编程中，使用代理模式开发RPC就是非常适合的
因为我们不涉及很多文本性内容，所以如果我们使用HTTP协议来涉及RPC服务调用框架来说，显得十分冗余，就不如涉及自己的序列化框架有效的减少数据传输量，在使用TCP协议进行传输

单体问题：
代理模式：使用JDK自带的动态代理可以做到调用者无感知，就像本地过程调用一样
序列化与协议：选用TCP作为我们RPC服务调用框架的传输协议，选用合适的序列化框架可以有效的减少数据传输量，加快服务访问速度（相对于高并发）
分布式问题：只要涉及到2台以上的服务器通信，必定会出现CAP，BASE问题
服务调用者：
1.负载均衡：一个服务存在多个实例，调用时如何获取某一个实例的地址呢？
2.容错隔离，服务降级
3.客户端异步调用，使用回调方法注册返回信息的处理

服务提供者：
1.服务提供者进行幂等性设计，版本控制
2.服务升级，停止提供服务时的处理：先从服务注册中心摘除注册节点，这样节点后续不会收到请求，等待目前请求的处理，等待所有请求处理完毕，进行系统的升级
3.有状态与无状态：有状态的服务器也应该将状态重新提取服务器，变为无状态

注册中心：
1.总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题

负载均衡算法：
wrr：weighted round robin
swrr：smooth weighted round robin





